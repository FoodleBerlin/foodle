import type { DMMF } from '@prisma/client/runtime';
import * as Nexus from 'nexus';
import { NexusEnumTypeConfig, NexusListDef, NexusNonNullDef, NexusNullDef } from 'nexus/dist/core';
import { Resolver } from '../../helpers/utils';
import { Gentime } from '../gentime/settingsSingleton';
import { Runtime } from '../runtime/settingsSingleton';
import { ModuleSpec } from '../types';
declare type PrismaModelOrEnumName = string;
declare type PrismaFieldName = string;
declare type PrismaModelFieldNameOrMetadataFieldName = string;
declare type NexusTypeDefConfigurations = Record<PrismaModelOrEnumName, NexusObjectTypeDefConfiguration | NexusEnumTypeDefConfiguration>;
export declare type Settings = {
    runtime: Runtime.Settings;
    gentime: Gentime.SettingsData;
};
/**
 * Create the module specification for the JavaScript runtime.
 */
export declare function createModuleSpec(params: {
    /**
     * Resolved generator settings (whatever user supplied merged with defaults).
     */
    gentimeSettings: Gentime.Settings;
    /**
     * Should the module be generated using ESM instead of CJS?
     */
    esm: boolean;
    /**
     * Detailed data about the Prisma Schema contents and available operations over its models.
     */
    dmmf: DMMF.Document;
}): ModuleSpec;
export declare function createNexusTypeDefConfigurations(dmmf: DMMF.Document, settings: Settings): NexusTypeDefConfigurations;
declare type NexusObjectTypeDefConfiguration = Record<PrismaModelFieldNameOrMetadataFieldName, {
    name: PrismaFieldName;
    type: NexusNonNullDef<string> | NexusListDef<string> | NexusNullDef<string>;
    description: string;
} | string | undefined>;
export declare function prismaFieldToNexusType(field: DMMF.Field, settings: Settings): Nexus.core.NexusNonNullDef<any> | Nexus.core.NexusNullDef<any>;
/**
 * Create a GraphQL resolver for the given Prisma field. If the Prisma field is a scalar then no resolver is
 * returned and instead the Nexus default is relied upon.
 *
 * @remarks Allow Nexus default resolver to handle resolving scalars.
 *
 *          By using Nexus default we also affect its generated types, assuming there are not explicit
 *          source types setup which actually for Nexus Prisma projects there usually will be (the Prisma
 *          model types). Still, using the Nexus default is a bit more idiomatic and provides the better
 *          _default_ type generation experience of scalars being expected to come down from the source
 *          type (aka. parent).
 *
 *          So:
 *
 *          ```ts ...
 *          t.field(M1.Foo.bar)
 *          ```
 *
 *          where `bar` is a scalar prisma field would have NO resolve generated and thus default Nexus
 *          as mentioned would think that `bar` field WILL be present on the source type. This is, again,
 *          mostly moot since most Nexus Prisma users WILL setup the Prisma source types e.g.:
 *
 *          ```ts ...
 *          sourceTypes: { modules: [{ module: '.prisma/client', alias: 'PrismaClient' }]},
 *          ```
 *
 *          but this is overall the better way to handle this detail it seems.
 */
export declare function nexusResolverFromPrismaField(model: DMMF.Model, field: DMMF.Field, settings: Settings): undefined | Resolver;
declare type AnyNexusEnumTypeConfig = NexusEnumTypeConfig<string>;
declare type NexusEnumTypeDefConfiguration = AnyNexusEnumTypeConfig;
export {};
//# sourceMappingURL=javascript.d.ts.map