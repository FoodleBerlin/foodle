import { chalk } from './chalk.js';
import * as Filter from './filter.js';
import * as Level from './level.js';
import * as Output from './output.js';
import { casesHandled, omitUndefinedKeys, parseFromEnvironment } from './utils.js';
/**
 * Process data setting input.
 */
export const processSettingInputData = (data, previous) => {
    if (!previous) {
        return {
            ...defaultSettingData(),
            ...omitUndefinedKeys(data)
        };
    }
    return {
        ...previous,
        ...omitUndefinedKeys(data ?? {})
    };
};
const defaultSettingData = () => {
    if (process.env?.[`NODE_ENV`] === `production`) {
        return {
            hostname: true,
            pid: true,
            time: true
        };
    }
    else {
        return {
            hostname: false,
            pid: false,
            time: false
        };
    }
};
/**
 * Process pretty setting input.
 */
export const processSettingInputPretty = (pretty, previous) => {
    // todo no semantic to "unset back to default"
    // consider using `null` for that purpose...
    const color = (typeof pretty === `object` ? pretty.color : undefined) ?? previous?.color ?? true;
    const enabled = (typeof pretty === `object` ? pretty.enabled : undefined) ??
        previous?.enabled ??
        // todo nice is-defined-but-parse-error feedback
        (process.env?.[`LOG_PRETTY`]?.toLowerCase() === `true`
            ? true
            : process.env?.[`LOG_PRETTY`]?.toLowerCase() === `false`
                ? false
                : process.stdout?.isTTY);
    const levelLabel = (typeof pretty === `object` ? pretty.levelLabel : undefined) ?? previous?.levelLabel ?? false;
    const timeDiff = (typeof pretty === `object` ? pretty.timeDiff : undefined) ?? previous?.timeDiff ?? true;
    if (pretty === undefined) {
        return { enabled, color, levelLabel, timeDiff };
    }
    if (pretty === true) {
        return { enabled: true, color, levelLabel, timeDiff };
    }
    if (pretty === false) {
        return { enabled: false, color, levelLabel, timeDiff };
    }
    if (typeof pretty === `object`) {
        return { enabled, color, levelLabel, timeDiff };
    }
    casesHandled(pretty);
    // TODO type error if removed, why?
    return { enabled, color, levelLabel, timeDiff };
};
export const create = (opts) => {
    const state = {
        pretty: processSettingInputPretty(opts?.pretty, null),
        filter: !opts || !opts.filter || opts.filter === `` || Object.keys(opts).length === 0
            ? defaultFilterSetting()
            : processSettingInputFilter(opts.filter, null),
        output: opts?.output ?? Output.defaultOutput,
        data: processSettingInputData(opts?.data ?? {}, null)
    };
    const settings = ((newSettings) => {
        if (newSettings.output) {
            // @ts-expect-error ...
            settings.output = newSettings.output;
        }
        if (`pretty` in newSettings) {
            // @ts-expect-error ...
            settings.pretty = processSettingInputPretty(newSettings.pretty, settings.pretty);
            // Sync chalk
            // Assume true color support, not doing all that -> https://github.com/chalk/chalk#256-and-truecolor-color-support
            chalk.level = settings.pretty.color ? 3 : 0;
        }
        if (`data` in newSettings) {
            // @ts-expect-error ...
            settings.data = processSettingInputData(newSettings.data, settings.data);
        }
        if (newSettings.filter && Object.keys(newSettings).length > 0) {
            // @ts-expect-error ...
            settings.filter = processSettingInputFilter(newSettings.filter, settings.filter);
        }
    });
    Object.assign(settings, state);
    return settings;
};
export const processSettingInputFilter = (newSettingsFilter, prev) => {
    if (!prev)
        prev = defaultFilterSetting();
    newSettingsFilter =
        typeof newSettingsFilter === `string` ? { pattern: newSettingsFilter } : newSettingsFilter;
    const pattern = newSettingsFilter.pattern ?? prev.originalInput;
    const defaults = newSettingsFilter?.level
        ? { level: { value: newSettingsFilter.level, comp: `gte` } }
        : prev.defaults;
    const patterns = Filter.processLogFilterInput(defaults, pattern) || Filter.parseUnsafe(defaults, `*`);
    return {
        defaults,
        originalInput: pattern,
        patterns
    };
};
export const defaultFilterSetting = () => {
    let level;
    if (process.env?.[`LOG_LEVEL`]) {
        level = parseFromEnvironment(`LOG_LEVEL`, Level.parser);
    }
    else {
        level = process.env?.[`NODE_ENV`] === `production` ? Level.LEVELS.info.label : Level.LEVELS.debug.label;
    }
    let originalInput;
    let patterns;
    if (process.env?.[`LOG_FILTER`]) {
        patterns = Filter.processLogFilterInput({ level: { value: level, comp: `gte` } }, process.env?.[`LOG_FILTER`], `environment variable LOG_FILTER.`);
    }
    if (!patterns) {
        originalInput = `*`;
        patterns = Filter.parseUnsafe({ level: { value: level, comp: `gte` } }, originalInput);
    }
    return {
        // TODO looks like it actually can be undefined, bug?
        // eslint-disable-next-line
        originalInput: originalInput,
        defaults: { level: { value: level, comp: `gte` } },
        patterns
    };
};
//# sourceMappingURL=settings.js.map