import * as Level from './level.js';
import type { LogRecord } from './logger.js';
import { ContextualError } from './utils.js';
export declare type Parsed = {
    originalInput: string;
    level: {
        value: Level.Name | '*';
        comp: 'lte' | 'gte' | 'eq';
    };
    negate: boolean;
    path: {
        value: string;
        descendants: false | {
            includeParent: boolean;
        };
    };
};
/**
 * Some of the criteria a pattern can specify are optional. When such criteria
 * are not specified, then these defaults are used.
 */
export declare type Defaults = {
    level: {
        value: Level.Name;
        comp: Parsed['level']['comp'];
    };
};
/**
 * Parse a full pattern. This accounts for lists of patterns. This is the parsing entrypoint.
 */
export declare const parse: (defaults: Defaults, pattern: string) => (ParseError | Parsed)[];
/**
 * Parse a single pattern. This assumes parsing of "," has already been handled
 * including whitespace trimming around the pattern.
 */
export declare const parseOne: (criteriaDefaults: Defaults, pattern: string) => ParseError | Parsed;
/**
 * Test if a log matches the pattern.
 */
export declare const test: (patterns: Readonly<Parsed[]>, log: LogRecord) => boolean;
/**
 * Like `parse` but throws upon any failure.
 *
 * @remarks
 *
 * Only use this if you know what you're doing.
 */
export declare const parseUnsafe: (defaults: Defaults, pattern: string) => Parsed[];
declare type ParseError = ContextualError<{
    pattern: string;
    hint?: string;
}>;
/**
 * Get the string contents of a manual showing how to write filters.
 */
export declare const renderSyntaxManual: () => string;
export declare const renderSyntaxError: (input: {
    errPatterns: (ParseError | Parsed)[];
    foundIn?: string;
    some?: boolean;
}) => string;
export declare const processLogFilterInput: (defaults: Defaults, pattern: string, foundIn?: string) => null | Parsed[];
export {};
//# sourceMappingURL=filter.d.ts.map