"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createContextualError = exports.parseFromEnvironment = exports.isEmpty = exports.last = exports.omitUndefinedKeys = exports.range = exports.constant = exports.casesHandled = exports.spanSpaceRight = exports.spanChar = exports.spanSpace = exports.clampSpace = exports.span = void 0;
const node_util_1 = require("node:util");
/**
 * Guarantee the length of a given string, padding before or after with the
 * given character. If the given string is longer than  the span target, then it
 * will be cropped.
 */
const span = (padSide, padChar, target, content) => {
    if (content.length > target) {
        return content.slice(0, target);
    }
    let toPadSize = target - content.length;
    while (toPadSize > 0) {
        if (padSide === `padAfter`) {
            content = content + padChar;
        }
        else if (padSide === `padBefore`) {
            content = padChar + content;
        }
        toPadSize--;
    }
    return content;
};
exports.span = span;
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned left and if exceeds span target length to begin with gets cropped.
 */
exports.clampSpace = exports.span.bind(null, `padAfter`, ` `);
/**
 * Create a string of space of the given length.
 */
const spanSpace = (num) => {
    return (0, exports.spanChar)(num, ` `);
};
exports.spanSpace = spanSpace;
/**
 * Create a string of the given length and character
 */
const spanChar = (num, char) => {
    return (0, exports.range)(num).map((0, exports.constant)(char)).join(``);
};
exports.spanChar = spanChar;
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned right and if exceeds span target length to begin with gets cropped.
 */
exports.spanSpaceRight = exports.span.bind(null, `padBefore`, ` `);
/**
 * Use this to make assertion at end of if-else chain that all members of a
 * union have been accounted for.
 */
const casesHandled = (x) => {
    // eslint-disable-next-line
    throw new Error(`A case of value was not handled: ${x}`);
};
exports.casesHandled = casesHandled;
/**
 * Create a function that will only ever return the given value when called.
 */
const constant = (x) => {
    return () => {
        return x;
    };
};
exports.constant = constant;
/**
 * Create a range of integers.
 */
const range = (times) => {
    const list = [];
    while (list.length < times) {
        list.push(list.length + 1);
    }
    return list;
};
exports.range = range;
/**
 * Strip keys from object whose value is undefined.
 */
const omitUndefinedKeys = (data) => {
    return Object.entries(data ?? {})
        .filter(([_, v]) => v !== undefined)
        .reduce((acc, [k, v]) => Object.assign(acc, { [k]: v }), {});
};
exports.omitUndefinedKeys = omitUndefinedKeys;
/**
 * Get the last item of an array.
 */
const last = (xs) => {
    return xs[xs.length - 1];
};
exports.last = last;
// eslint-disable-next-line
const isEmpty = (x) => {
    if (typeof x === `string` && x === ``)
        return true;
    if (x === undefined)
        return true;
    return Object.values(x).filter((val) => val !== undefined).length === 0;
};
exports.isEmpty = isEmpty;
/**
 * Run a given parser over an environment variable. If parsing fails, throw a
 * contextual error message.
 */
const parseFromEnvironment = (key, parser) => {
    // eslint-disable-next-line
    const envVarValue = process.env[key]; // assumes env presence handled before
    const result = parser.run(envVarValue);
    if (result === null) {
        throw new Error(`Could not parse environment variable ${key} into ${parser.info.typeName}. The environment variable was: ${(0, node_util_1.format)(envVarValue)}. A valid environment variable must be like: ${parser.info.valid}`);
    }
    return result;
};
exports.parseFromEnvironment = parseFromEnvironment;
/**
 * Create an error with contextual data about it.
 */
const createContextualError = (message, context) => {
    const e = new Error(message);
    Object.defineProperty(e, `message`, {
        enumerable: true,
        value: e.message
    });
    e.context = context;
    return e;
};
exports.createContextualError = createContextualError;
//# sourceMappingURL=utils.cjs.map