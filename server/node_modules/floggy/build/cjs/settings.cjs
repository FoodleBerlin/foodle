"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultFilterSetting = exports.processSettingInputFilter = exports.create = exports.processSettingInputPretty = exports.processSettingInputData = void 0;
const chalk_cjs_1 = require("./chalk.cjs");
const Filter = __importStar(require("./filter.cjs"));
const Level = __importStar(require("./level.cjs"));
const Output = __importStar(require("./output.cjs"));
const utils_cjs_1 = require("./utils.cjs");
/**
 * Process data setting input.
 */
const processSettingInputData = (data, previous) => {
    if (!previous) {
        return {
            ...defaultSettingData(),
            ...(0, utils_cjs_1.omitUndefinedKeys)(data)
        };
    }
    return {
        ...previous,
        ...(0, utils_cjs_1.omitUndefinedKeys)(data ?? {})
    };
};
exports.processSettingInputData = processSettingInputData;
const defaultSettingData = () => {
    if (process.env?.[`NODE_ENV`] === `production`) {
        return {
            hostname: true,
            pid: true,
            time: true
        };
    }
    else {
        return {
            hostname: false,
            pid: false,
            time: false
        };
    }
};
/**
 * Process pretty setting input.
 */
const processSettingInputPretty = (pretty, previous) => {
    // todo no semantic to "unset back to default"
    // consider using `null` for that purpose...
    const color = (typeof pretty === `object` ? pretty.color : undefined) ?? previous?.color ?? true;
    const enabled = (typeof pretty === `object` ? pretty.enabled : undefined) ??
        previous?.enabled ??
        // todo nice is-defined-but-parse-error feedback
        (process.env?.[`LOG_PRETTY`]?.toLowerCase() === `true`
            ? true
            : process.env?.[`LOG_PRETTY`]?.toLowerCase() === `false`
                ? false
                : process.stdout?.isTTY);
    const levelLabel = (typeof pretty === `object` ? pretty.levelLabel : undefined) ?? previous?.levelLabel ?? false;
    const timeDiff = (typeof pretty === `object` ? pretty.timeDiff : undefined) ?? previous?.timeDiff ?? true;
    if (pretty === undefined) {
        return { enabled, color, levelLabel, timeDiff };
    }
    if (pretty === true) {
        return { enabled: true, color, levelLabel, timeDiff };
    }
    if (pretty === false) {
        return { enabled: false, color, levelLabel, timeDiff };
    }
    if (typeof pretty === `object`) {
        return { enabled, color, levelLabel, timeDiff };
    }
    (0, utils_cjs_1.casesHandled)(pretty);
    // TODO type error if removed, why?
    return { enabled, color, levelLabel, timeDiff };
};
exports.processSettingInputPretty = processSettingInputPretty;
const create = (opts) => {
    const state = {
        pretty: (0, exports.processSettingInputPretty)(opts?.pretty, null),
        filter: !opts || !opts.filter || opts.filter === `` || Object.keys(opts).length === 0
            ? (0, exports.defaultFilterSetting)()
            : (0, exports.processSettingInputFilter)(opts.filter, null),
        output: opts?.output ?? Output.defaultOutput,
        data: (0, exports.processSettingInputData)(opts?.data ?? {}, null)
    };
    const settings = ((newSettings) => {
        if (newSettings.output) {
            // @ts-expect-error ...
            settings.output = newSettings.output;
        }
        if (`pretty` in newSettings) {
            // @ts-expect-error ...
            settings.pretty = (0, exports.processSettingInputPretty)(newSettings.pretty, settings.pretty);
            // Sync chalk
            // Assume true color support, not doing all that -> https://github.com/chalk/chalk#256-and-truecolor-color-support
            chalk_cjs_1.chalk.level = settings.pretty.color ? 3 : 0;
        }
        if (`data` in newSettings) {
            // @ts-expect-error ...
            settings.data = (0, exports.processSettingInputData)(newSettings.data, settings.data);
        }
        if (newSettings.filter && Object.keys(newSettings).length > 0) {
            // @ts-expect-error ...
            settings.filter = (0, exports.processSettingInputFilter)(newSettings.filter, settings.filter);
        }
    });
    Object.assign(settings, state);
    return settings;
};
exports.create = create;
const processSettingInputFilter = (newSettingsFilter, prev) => {
    if (!prev)
        prev = (0, exports.defaultFilterSetting)();
    newSettingsFilter =
        typeof newSettingsFilter === `string` ? { pattern: newSettingsFilter } : newSettingsFilter;
    const pattern = newSettingsFilter.pattern ?? prev.originalInput;
    const defaults = newSettingsFilter?.level
        ? { level: { value: newSettingsFilter.level, comp: `gte` } }
        : prev.defaults;
    const patterns = Filter.processLogFilterInput(defaults, pattern) || Filter.parseUnsafe(defaults, `*`);
    return {
        defaults,
        originalInput: pattern,
        patterns
    };
};
exports.processSettingInputFilter = processSettingInputFilter;
const defaultFilterSetting = () => {
    let level;
    if (process.env?.[`LOG_LEVEL`]) {
        level = (0, utils_cjs_1.parseFromEnvironment)(`LOG_LEVEL`, Level.parser);
    }
    else {
        level = process.env?.[`NODE_ENV`] === `production` ? Level.LEVELS.info.label : Level.LEVELS.debug.label;
    }
    let originalInput;
    let patterns;
    if (process.env?.[`LOG_FILTER`]) {
        patterns = Filter.processLogFilterInput({ level: { value: level, comp: `gte` } }, process.env?.[`LOG_FILTER`], `environment variable LOG_FILTER.`);
    }
    if (!patterns) {
        originalInput = `*`;
        patterns = Filter.parseUnsafe({ level: { value: level, comp: `gte` } }, originalInput);
    }
    return {
        // TODO looks like it actually can be undefined, bug?
        // eslint-disable-next-line
        originalInput: originalInput,
        defaults: { level: { value: level, comp: `gte` } },
        patterns
    };
};
exports.defaultFilterSetting = defaultFilterSetting;
//# sourceMappingURL=settings.cjs.map