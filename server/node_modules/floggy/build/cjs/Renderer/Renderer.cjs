"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.render = exports.separators = void 0;
const chalk_cjs_1 = require("../chalk.cjs");
const Level = __importStar(require("../level.cjs"));
const utils = __importStar(require("../utils.cjs"));
const Os = __importStar(require("node:os"));
const util = __importStar(require("node:util"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
/**
 * Create a stop watch. Makes it simple to calculate elapsed time on every
 * invocation of `lap`.
 */
const createStopWatch = () => {
    let prev = Date.now();
    return {
        lap: () => {
            const curr = Date.now();
            const elapsed = curr - prev;
            prev = curr;
            return elapsed;
        }
    };
};
const stopWatch = createStopWatch();
// Helpful unicode pickers:
// - https://jrgraphix.net/r/Unicode/2600-26FF
// - https://graphemica.com/
const LEVEL_STYLES = {
    fatal: {
        // badge: '⚰',
        // badge: '☠',
        badge: `✕`,
        color: chalk_cjs_1.chalk.red
    },
    error: {
        badge: `■`,
        color: chalk_cjs_1.chalk.red
    },
    warn: {
        badge: `▲`,
        color: chalk_cjs_1.chalk.yellow
    },
    info: {
        // badge: '↣',
        badge: `●`,
        color: chalk_cjs_1.chalk.green
    },
    debug: {
        // badge: '◒',
        badge: `○`,
        // badge: '⚒',
        // badge: '↺',
        // badge: '↯',
        // badge: '⟐',
        color: chalk_cjs_1.chalk.blue
    },
    trace: {
        badge: `—`,
        // badge: '~',
        // badge: '⟣',
        // badge: '⟛',
        // badge: '⠿',
        color: chalk_cjs_1.chalk.magenta
    }
};
exports.separators = {
    path: {
        symbol: `:`
    },
    event: {
        symbol: ` `
    },
    context: {
        singleLine: {
            symbol: `  --  `,
            // context = ` ${chalk.gray('⸬')}  ` + context
            // context = ` ${chalk.gray('•')}  ` + context
            // context = ` ${chalk.gray('⑊')}  ` + context
            // context = ` ${chalk.gray('//')}  ` + context
            // context = ` ${chalk.gray('—')}  ` + context
            // context = ` ${chalk.gray('~')}  ` + context
            // context = ` ${chalk.gray('⌀')}  ` + context
            // context = ` ${chalk.gray('——')}  ` + context
            // context = ` ${chalk.gray('❯')}  ` + context
            // context = ` ${chalk.gray('->')}  ` + context
            // context = ` ${chalk.gray('⌁')}  ` + context
            // context = ` ${chalk.gray('⋯')}  ` + context
            // context = ` ${chalk.gray('⌁')}  ` + context
            // context = ` ${chalk.gray('⟛')}  ` + context
            color: chalk_cjs_1.chalk.gray
        },
        multiline: {
            symbol: ``
        }
    },
    contextKeyVal: {
        singleLine: {
            symbol: `: `,
            color: chalk_cjs_1.chalk.gray
        },
        multiline: {
            symbol: `  `
        }
    },
    contextEntry: {
        singleLine: `  `,
        multiline: (gutterSpace) => ({
            symbol: gutterSpace + `| `,
            color: chalk_cjs_1.chalk.gray
        })
    }
};
const render = (opts, logRecord) => {
    const terminalWidth = process.stdout.columns ?? 80;
    const levelLabel = Level.LEVELS_BY_NUM[logRecord.level].label;
    const style = LEVEL_STYLES[levelLabel];
    //
    // render time diff
    //
    let timeDiff = ``;
    let timeDiffRendered = ``;
    if (opts.timeDiff) {
        let elapsedTime = stopWatch.lap();
        let unit;
        // <10s
        if (elapsedTime < 1000 * 10) {
            unit = `ms`;
            // 10s-100s (exclusive)
        }
        else if (elapsedTime >= 1000 * 10 && elapsedTime < 1000 * 100) {
            elapsedTime = Math.round(elapsedTime / 1000);
            unit = `s`;
            // 100s-60m (exclusive)
        }
        else if (elapsedTime >= 1000 * 100 && elapsedTime < 1000 * 60 * 60) {
            elapsedTime = Math.round(elapsedTime / 1000 / 60);
            unit = `m`;
            // 1h-24h (exclusive)
        }
        else if (elapsedTime >= 1000 * 60 * 60 && elapsedTime < 1000 * 60 * 60 * 24) {
            elapsedTime = Math.round(elapsedTime / 1000 / 60 / 60);
            unit = `h`;
            // 1d-999d (exclusive)
        }
        else if (elapsedTime >= 1000 * 60 * 60 * 24 && elapsedTime < 1000 * 60 * 60 * 24 * 10) {
            elapsedTime = Math.round(elapsedTime / 1000 / 60 / 60 / 24);
            unit = `d`;
        }
        else {
            unit = `max`;
        }
        if (unit === `ms`) {
            timeDiff = `${utils.spanSpaceRight(4, String(elapsedTime))} `;
        }
        else if (unit === `max`) {
            timeDiff = ` ∞ `;
        }
        else {
            timeDiff = `${unit} ${utils.spanSpaceRight(2, String(elapsedTime))} `;
        }
        timeDiffRendered = chalk_cjs_1.chalk.gray(timeDiff);
    }
    //
    // render gutter
    //
    const levelLabelSized = opts.levelLabel ? ` ` + utils.clampSpace(5, levelLabel) + ` ` : ` `;
    const gutterRendered = `${timeDiffRendered}${style.color(`${style.badge}${levelLabelSized}`)}`;
    // pre-emptyive measurement for potential multiline context indentation later on
    const gutterWidth = timeDiff.length + style.badge.length + levelLabelSized.length;
    /**
     * Render Pre-Context
     *
     * Path is null when log came from root.
     */
    const path = logRecord.path?.join(renderEl(exports.separators.path)) ?? ``;
    const preContextWidth = path
        ? path.length + exports.separators.event.symbol.length + logRecord.event.length
        : logRecord.event.length;
    const preContextRendered = path
        ? style.color(path) + renderEl(exports.separators.event) + logRecord.event
        : logRecord.event;
    //
    // render context
    //
    // Factor in:
    // 1. the headers section
    // 2. the headers/context separator
    const availableSinglelineContextColumns = terminalWidth - gutterWidth - preContextWidth - exports.separators.context.singleLine.symbol.length;
    let contextColumnsConsumed = 0;
    const contextEntries = logRecord.context ? Object.entries(logRecord.context) : [];
    let widestKey = 0;
    let first = true;
    const contextEntriesRendered = contextEntries.map(([key, value]) => {
        // Track context space consumption of entry separators
        if (!first)
            contextColumnsConsumed += exports.separators.contextEntry.singleLine.length;
        else
            first = false;
        // Track widest key optimistically for use in multiline layout later
        if (key.length > widestKey)
            widestKey = key.length;
        contextColumnsConsumed += key.length + exports.separators.contextKeyVal.singleLine.symbol.length;
        const valueRendered = `${util.inspect(value, {
            breakLength: availableSinglelineContextColumns,
            colors: opts.color,
            getters: true,
            depth: 20
        })}`;
        // todo probably not cheap, calculate instead by running a context columns consumed tally
        // this is also the only use-case for stripAnsi and then we can drop the dep
        contextColumnsConsumed += (0, strip_ansi_1.default)(valueRendered).length;
        return [key, valueRendered];
    });
    const contextFitsSingleLine = contextColumnsConsumed <= availableSinglelineContextColumns;
    let contextRendered = ``;
    if (contextEntries.length > 0) {
        if (contextFitsSingleLine) {
            contextRendered =
                renderEl(exports.separators.context.singleLine) +
                    contextEntriesRendered
                        .map(
                    // eslint-disable-next-line
                    ([key, value]) => `${chalk_cjs_1.chalk.gray(key)}${renderEl(exports.separators.contextKeyVal.singleLine)}${value}`)
                        .join(exports.separators.contextEntry.singleLine);
        }
        else {
            const spineRendered = renderEl(exports.separators.contextEntry.multiline(utils.spanSpace(gutterWidth)));
            contextRendered =
                renderEl(exports.separators.context.multiline) +
                    `\n` +
                    spineRendered +
                    contextEntriesRendered
                        .map(([key, value]) => 
                    // eslint-disable-next-line
                    `${chalk_cjs_1.chalk.gray(utils.clampSpace(widestKey, key))}${renderEl(exports.separators.contextKeyVal.multiline
                    // eslint-disable-next-line
                    )}${formatBlock(value, {
                        leftSpineSymbol: spineRendered,
                        excludeFirstLine: true,
                        indent: widestKey + exports.separators.contextKeyVal.multiline.symbol.length
                    })}`)
                        .join(`\n` + spineRendered);
        }
    }
    //
    // put it together
    //
    return `${gutterRendered}${preContextRendered}${contextRendered}${Os.EOL}`;
};
exports.render = render;
const renderEl = (el) => {
    return el.color ? el.color(el.symbol) : el.symbol;
};
/**
 * Given a multiline string, run a single pass over each line carrying out the
 * given transformations configured in given options.
 *
 * If singleline given, returned as-is.
 */
const formatBlock = (block, opts) => {
    const [first, ...rest] = block.split(`\n`);
    // eslint-disable-next-line
    if (rest.length === 0)
        return first;
    // eslint-disable-next-line
    const linesToProcess = opts.excludeFirstLine === true ? rest : (rest.unshift(first), rest);
    const prefix = typeof opts.leftSpineSymbol === `string` ? opts.leftSpineSymbol : opts.leftSpineSymbol?.symbol ?? ``;
    const indent = opts.indent !== undefined ? utils.spanSpace(opts.indent) : ``;
    const linesProcessed = opts.excludeFirstLine === true ? [first] : [];
    for (const line of linesToProcess) {
        const prefixRendered = typeof opts.leftSpineSymbol === `object` ? opts.leftSpineSymbol?.color?.(prefix) ?? prefix : prefix;
        linesProcessed.push(prefixRendered + indent + line);
    }
    return linesProcessed.join(`\n`);
};
//# sourceMappingURL=Renderer.cjs.map