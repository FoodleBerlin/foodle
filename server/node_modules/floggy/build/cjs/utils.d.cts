/**
 * Guarantee the length of a given string, padding before or after with the
 * given character. If the given string is longer than  the span target, then it
 * will be cropped.
 */
export declare const span: (padSide: 'padBefore' | 'padAfter', padChar: string, target: number, content: string) => string;
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned left and if exceeds span target length to begin with gets cropped.
 */
export declare const clampSpace: (target: number, content: string) => string;
/**
 * Create a string of space of the given length.
 */
export declare const spanSpace: (num: number) => string;
/**
 * Create a string of the given length and character
 */
export declare const spanChar: (num: number, char: string) => string;
/**
 * Guarantee the length of a given string, padding with space as needed. Content
 * is aligned right and if exceeds span target length to begin with gets cropped.
 */
export declare const spanSpaceRight: (target: number, content: string) => string;
/**
 * Use this to make assertion at end of if-else chain that all members of a
 * union have been accounted for.
 */
export declare const casesHandled: (x: never) => never;
/**
 * Create a function that will only ever return the given value when called.
 */
export declare const constant: <T extends unknown>(x: T) => () => T;
/**
 * Create a range of integers.
 */
export declare const range: (times: number) => number[];
/**
 * Strip keys from object whose value is undefined.
 */
export declare const omitUndefinedKeys: <T extends Record<string, unknown>>(data: T) => T;
/**
 * Get the last item of an array.
 */
export declare const last: <T extends unknown>(xs: T[]) => T | undefined;
export declare const isEmpty: (x?: object | string) => boolean;
/**
 * Run a given parser over an environment variable. If parsing fails, throw a
 * contextual error message.
 */
export declare const parseFromEnvironment: <T extends unknown>(key: string, parser: {
    info: {
        valid: string;
        typeName: string;
    };
    run: (raw: string) => T | null;
}) => T;
/**
 * An error with additional contextual data.
 */
export declare type ContextualError<Context extends Record<string, unknown> = {}> = Error & {
    context: Context;
};
/**
 * Create an error with contextual data about it.
 */
export declare const createContextualError: <Context extends Record<string, unknown>>(message: string, context: Context) => ContextualError<Context>;
//# sourceMappingURL=utils.d.cts.map